<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Kare Kapmaca</title>
<link rel="stylesheet" href="../style.css">
<style>
  :root{
    --panel:#071021; --muted:#9aa4b2;
    --red:#ef4444; --blue:#2563eb; --dot:#e6eef8;
    --ui-pad:12px;
  }
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color: var(--text); background: var(--bg);}
  .app{display:flex;flex-direction:column;height:100vh;gap:10px;padding:10px;box-sizing:border-box}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .title{font-weight:700;font-size:18px}
  .controls{display:flex;gap:8px;align-items:center}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;color:var(--dot);font-weight:600}
  .status{display:flex;gap:12px;align-items:center}
  .playerBadge{display:flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02)}
  .colorDot{width:14px;height:14px;border-radius:50%;box-shadow:0 1px 0 rgba(0,0,0,0.4) inset}
  .score{font-weight:800;font-size:16px}

  /* game area stretches to remaining height */
  .boardWrap{flex:1;display:flex;align-items:center;justify-content:center; color:var(--card);}
  /* svg takes full width on mobile and fits in container */
  svg{width:100%;height:100%;max-width:1000px;max-height:calc(100vh - 160px);touch-action: manipulation}

  /* small help */
  .footer{font-size:13px;color:var(--muted);text-align:center;padding:6px}

  /* make touch targets bigger visually invisible */
  .edgeHit{cursor:pointer}
  .edgeLine{stroke-linecap:round;stroke-width:6}
  .edgeDisabled{opacity:0.06;cursor:not-allowed}
  .boxFill{opacity:0.12}

  /* responsive tweaks */
  @media (max-width:520px){
    .title{font-size:16px}
    button{padding:8px;border-radius:8px}
  }
.textcolor{
  color: var(--text);
}
</style>
</head>
<body>
<div class="app">
  <header>
    <div>
      <div class="title textcolor">Kare Kapmaca</div>
      <div class="textcolor" style="font-size:12px;color:var(--muted)">Kırmızı vs Mavi • Kare yapan tekrar oynar</div>
    </div>
    <div class="controls">
      <div class="status">
        <div class="playerBadge" id="currentPlayer">
          <div class="colorDot" id="currentColor" style="background:var(--red)"></div>
          <div class="textcolor" id="playerText">Sıra: Kırmızı</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <div style="text-align:right">
            <div class="textcolor" style="font-size:12px;color:var(--muted)">Kırmızı</div>
            <div class="score textcolor" id=scoreRed>0</div>
          </div>
          <div style="text-align:right">
            <div class="textcolor" style="font-size:12px;color:var(--muted)">Mavi</div>
            <div class="score textcolor" id="scoreBlue">0</div>
          </div>
        </div>
      </div>
      <button id="restartBtn">Yeniden Başlat</button>
      <button onclick="goMenu()" class="buton C">Ana Menü</button>
    </div>
  </header>

  <div class="boardWrap">
    <!-- SVG board will be generated by JS -->
    <svg id="gameSvg" viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMid meet"></svg>
  </div>

  <div class="footer">Kenarlara dokun/tıkla. Tamamlanan kare 1 puan. Oyun bittiğinde puanı yüksek olan kazanır.</div>
</div>

<script>
(function(){
  // Configuration
  const ROWS = 10; // boxes vertically
  const COLS = 10; // boxes horizontally
  const DOT_SPACING = 80; // internal SVG units
  const DOT_R = 5;
  const HIT_THICK = 18; // hit area thickness

  const COLORS = {red: getComputedStyle(document.documentElement).getPropertyValue('--red').trim() || '#ef4444', blue: getComputedStyle(document.documentElement).getPropertyValue('--blue').trim() || '#2563eb'};
  const svg = document.getElementById('gameSvg');
  const scoreRedEl = document.getElementById('scoreRed');
  const scoreBlueEl = document.getElementById('scoreBlue');
  const currentColorEl = document.getElementById('currentColor');
  const playerTextEl = document.getElementById('playerText');
  const restartBtn = document.getElementById('restartBtn');

  // Internal board state
  // horizontals: (ROWS+1) x COLS
  // verticals: ROWS x (COLS+1)
  let horizontals = [];
  let verticals = [];
  let boxes = []; // ROWS x COLS -> owner or null

  let currentPlayer = 'red';
  let scores = {red:0, blue:0};
  let remainingEdges = 0;

  function initState(){
    horizontals = Array.from({length: ROWS+1}, ()=>Array(COLS).fill(null));
    verticals = Array.from({length: ROWS}, ()=>Array(COLS+1).fill(null));
    boxes = Array.from({length: ROWS}, ()=>Array(COLS).fill(null));
    scores = {red:0, blue:0};
    currentPlayer = 'red';
  }

  function buildSvg(){
    // compute size
    const width = COLS * DOT_SPACING;
    const height = ROWS * DOT_SPACING;
    const viewW = width + DOT_SPACING; // add margin
    const viewH = height + DOT_SPACING;
    svg.setAttribute('viewBox', `0 0 ${viewW} ${viewH}`);
    svg.innerHTML = '';

    // group layers
    const defs = createEl('defs');
    svg.appendChild(defs);

    // background rect for touch clearing
    svg.appendChild(createEl('rect',{x:0,y:0,width:viewW,height:viewH,fill:'transparent'}));

    const gridGroup = createEl('g',{id:'grid'});
    svg.appendChild(gridGroup);

    const offsetX = DOT_SPACING/2;
    const offsetY = DOT_SPACING/2;

    // draw boxes (as rects to be filled when claimed)
    const boxesG = createEl('g',{id:'boxes'});
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const x = offsetX + c*DOT_SPACING;
        const y = offsetY + r*DOT_SPACING;
        const rect = createEl('rect',{
          x:x+6, y:y+6, width:DOT_SPACING-12, height:DOT_SPACING-12, fill:'transparent', 'data-r':r, 'data-c':c, class:'boxFill', id:`box-${r}-${c}`
        });
        boxesG.appendChild(rect);
      }
    }
    gridGroup.appendChild(boxesG);

    // draw horizontal edges
    const hG = createEl('g',{id:'horizontals'});
    for(let r=0;r<=ROWS;r++){
      for(let c=0;c<COLS;c++){
        const x1 = offsetX + c*DOT_SPACING;
        const y1 = offsetY + r*DOT_SPACING;
        const x2 = offsetX + (c+1)*DOT_SPACING;
        const y2 = y1;
        // visible line (initially faint)
        const line = createEl('line',{x1:x1+DOT_R, y1:y1, x2:x2-DOT_R, y2:y2, stroke:'rgba(255,255,255,0.06)', 'stroke-width':6, class:'edgeLine', id:`hline-${r}-${c}`});
        // hit rect bigger for easy touch
        const hx = x1; const hy = y1 - HIT_THICK/2; const hw = DOT_SPACING; const hh = HIT_THICK;
        const hit = createEl('rect',{x:hx, y:hy, width:hw, height:hh, fill:'transparent', class:'edgeHit', 'data-type':'h', 'data-r':r, 'data-c':c});
        hG.appendChild(line);
        hG.appendChild(hit);
      }
    }
    gridGroup.appendChild(hG);

    // draw vertical edges
    const vG = createEl('g',{id:'verticals'});
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<=COLS;c++){
        const x1 = offsetX + c*DOT_SPACING;
        const y1 = offsetY + r*DOT_SPACING;
        const x2 = x1;
        const y2 = offsetY + (r+1)*DOT_SPACING;
        const line = createEl('line',{x1:x1, y1:y1+DOT_R, x2:x2, y2:y2-DOT_R, stroke:'rgba(255,255,255,0.06)', 'stroke-width':6, class:'edgeLine', id:`vline-${r}-${c}`});
        const hx = x1 - HIT_THICK/2; const hy = y1; const hw = HIT_THICK; const hh = DOT_SPACING;
        const hit = createEl('rect',{x:hx, y:hy, width:hw, height:hh, fill:'transparent', class:'edgeHit', 'data-type':'v', 'data-r':r, 'data-c':c});
        vG.appendChild(line);
        vG.appendChild(hit);
      }
    }
    gridGroup.appendChild(vG);

    // draw dots on top
    const dotsG = createEl('g',{id:'dots'});
    for(let r=0;r<=ROWS;r++){
      for(let c=0;c<=COLS;c++){
        const x = offsetX + c*DOT_SPACING;
        const y = offsetY + r*DOT_SPACING;
        const circle = createEl('circle',{cx:x, cy:y, r:DOT_R, fill:'var(--dot)'});
        dotsG.appendChild(circle);
      }
    }
    svg.appendChild(dotsG);

    // attach event listeners for all hit rects
    svg.querySelectorAll('.edgeHit').forEach(el=>{
      el.addEventListener('click', onEdgeClick);
      el.addEventListener('touchstart', function(e){ e.preventDefault(); onEdgeClick.call(this,e); }, {passive:false});
    });

    // calculate remaining edges
    remainingEdges = (ROWS+1)*COLS + ROWS*(COLS+1);
  }

  function createEl(tag, attrs={}){
    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
    for(const k in attrs){ el.setAttribute(k, attrs[k]); }
    return el;
  }

  function onEdgeClick(e){
    const t = e.currentTarget || e.target;
    const type = t.getAttribute('data-type');
    const r = parseInt(t.getAttribute('data-r'));
    const c = parseInt(t.getAttribute('data-c'));
    if(type==='h'){
      if(horizontals[r][c]) return; // already taken
      claimEdge('h', r, c);
    } else {
      if(verticals[r][c]) return;
      claimEdge('v', r, c);
    }
  }

  function claimEdge(type, r, c){
    // mark
    if(type==='h') horizontals[r][c] = currentPlayer;
    else verticals[r][c] = currentPlayer;

    // render line color
    const id = type==='h' ? `hline-${r}-${c}` : `vline-${r}-${c}`;
    const line = svg.getElementById(id);
    if(line){ line.setAttribute('stroke', COLORS[currentPlayer]); line.setAttribute('stroke-width', 8); }

    remainingEdges--;

    // check adjacent boxes for completion
    const completed = [];
    if(type==='h'){
      // box above: r-1,c
      if(r-1 >= 0){ if(isBoxCompleted(r-1,c)) completed.push([r-1,c]); }
      // box below: r,c
      if(r < ROWS){ if(isBoxCompleted(r,c)) completed.push([r,c]); }
    } else {
      // vertical
      // left box: r,c-1
      if(c-1 >= 0){ if(isBoxCompleted(r,c-1)) completed.push([r,c-1]); }
      // right box: r,c
      if(c < COLS){ if(isBoxCompleted(r,c)) completed.push([r,c]); }
    }

    let scored = 0;
    for(const [br,bc] of completed){
      if(boxes[br][bc]) continue; // already claimed earlier
      boxes[br][bc] = currentPlayer;
      scored++;
      // fill box
      const boxEl = svg.getElementById(`box-${br}-${bc}`);
      if(boxEl){ boxEl.setAttribute('fill', COLORS[currentPlayer]); boxEl.setAttribute('opacity', 0.16); }
    }

    if(scored>0){
      scores[currentPlayer] += scored;
      // current player keeps the turn
    } else {
      // switch player
      currentPlayer = (currentPlayer==='red') ? 'blue' : 'red';
    }

    updateUI();

    // disable hit area by setting pointer-events none on the specific rect
    // find the hit rect matching
    const selector = `[data-type='${type}'][data-r='${r}'][data-c='${c}']`;
    const hit = svg.querySelector(selector);
    if(hit){ hit.style.pointerEvents = 'none'; hit.classList.add('edgeDisabled'); }

    // game end
    if(remainingEdges === 0){
      setTimeout(()=>gameOver(), 50);
    }
  }

  function isBoxCompleted(br, bc){
    // top: horizontals[br][bc]
    // bottom: horizontals[br+1][bc]
    // left: verticals[br][bc]
    // right: verticals[br][bc+1]
    const top = horizontals[br][bc];
    const bottom = horizontals[br+1][bc];
    const left = verticals[br][bc];
    const right = verticals[br][bc+1];
    return Boolean(top && bottom && left && right);
  }

  function updateUI(){
    scoreRedEl.textContent = scores.red;
    scoreBlueEl.textContent = scores.blue;
    currentColorEl.style.background = COLORS[currentPlayer];
    playerTextEl.textContent = `Sıra: ${currentPlayer==='red' ? 'Kırmızı' : 'Mavi'}`;
  }

  function gameOver(){
    let winner = null;
    if(scores.red > scores.blue) winner = 'Kırmızı kazandı!';
    else if(scores.blue > scores.red) winner = 'Mavi kazandı!';
    else winner = 'Berabere!';
    alert(`Oyun bitti. ${winner} \nSkor: Kırmızı ${scores.red} — Mavi ${scores.blue}`);
  }

  function restart(){
    initState();
    buildSvg();
    updateUI();
  }

  // initial
  initState();
  buildSvg();
  updateUI();

  restartBtn.addEventListener('click', ()=>{
    if(confirm('Oyunu yeniden başlatmak istiyor musunuz?')) restart();
  });

  // allow keyboard shortcuts for desktop testing
  window.addEventListener('keydown', (e)=>{
    if(e.key==='r') restart();
  });

})();
    function goMenu() {
    window.location.href = "../../index.html"; 
}
/*---------------TEMA----------------*/
function setTheme(theme) {
  document.documentElement.setAttribute("data-theme", theme);
  localStorage.setItem("theme", theme);

  if (theme === "light") {
    const savedBg = localStorage.getItem("lightBg");
    if (savedBg) {
      document.documentElement.style.setProperty("--bg", savedBg);
    }
  } else {
    document.documentElement.style.removeProperty("--bg");
  }
}

// sayfa açılınca
window.addEventListener("DOMContentLoaded", () => {
  const theme = localStorage.getItem("theme") || "dark";
  document.documentElement.setAttribute("data-theme", theme);

  if (theme === "light") {
    const savedBg = localStorage.getItem("lightBg");
    if (savedBg) {
      document.documentElement.style.setProperty("--bg", savedBg);
    }
  }
});

// light tema arka planı
function setLightBg(color) {
  document.documentElement.style.setProperty("--bg", color);
  localStorage.setItem("lightBg", color);
}
window.addEventListener("DOMContentLoaded", () => {
  const theme = localStorage.getItem("theme") || "dark";
  document.documentElement.setAttribute("data-theme", theme);

  if (theme === "dark") {
    // DARK ise XOX arka planı sabitle
    document.documentElement.style.setProperty("--bg", "#0f1724");
  } else {
    // LIGHT ise seçilen light rengini kullan
    const savedBg = localStorage.getItem("lightBg");
    if (savedBg) {
      document.documentElement.style.setProperty("--bg", savedBg);
    }
  }
});

</script>
</body>
</html>
